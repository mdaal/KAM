if 0:
	try:
		del sweep
	except:
		pass

	reload(iqsweep_ucb)

	sweep =  iqsweep_ucb.IQsweep()



	#sweep.LoadMat(mat,0)
	sweep.LoadSWP('0-1-54.sweep',0)
	print('Data Loaded')
	sweep.FitMagMP()
	print('Mag Fit Done')
	sweep.FitLoopMP()
	print('Loop Fit Done')

if 0:
	import KAM
	reload(KAM)
	k = KAM.sweep()
	#k.download_data('http://cosmology.berkeley.edu/~miguel/private/KIPS_Data/Data/Run45b/P_Sweep/Feb6/ScanData_Backup.mat') # single Res powersweep
	#k.download_data('http://cosmology.berkeley.edu/~miguel/private/KIPS_Data/Data/Run45a/TP_Sweep/ScanData_Backup.mat') #single res TP sweep
	#k.download_data('http://cosmology.berkeley.edu/~miguel/private/KIPS_Data/Data/Run33b/TP_Sweep/33b_ScanData_52mK_201172315038.mat') #multiple resonator (e.g multiple freq ranges) TP sweep
	#k.download_data('http://cosmology.berkeley.edu/~miguel/private/KIPS_Data/Data/Run44b/TP_Sweep/44b_ScanData_40mK_201312196158.mat') # Single re TP sweep, run 44b temp power sweep
	#k.download_data('http://cosmology.berkeley.edu/~miguel/private/KIPS_Data/Data/Run44b/Survey/44b_ScanData_40mK_20131218112528.mat') # Survey run 44b survey, single power
	#k.download_data('http://cosmology.berkeley.edu/~miguel/private/KIPS_Data/Data/Run44a/TP_Sweep/44a_ScanData_40mK_20131220154159.mat') # Single Res TP sweep, complete data -- BAD Resonance
	k.download_data('http://cosmology.berkeley.edu/~miguel/private/KIPS_Data/Data/Run40b/TP_Sweep/40b_ScanData_57mK_20127421435.mat') # Singel Res Temp Power Sweep
	k.load_scandata()
	#range_num = 0; heater_voltage = 6; k.Freq_Range[range_num][1]['Temp'][0][0][heater_voltage][1]['PowerSweep']
	#range_num = 0 when there is only 1  frequency range number

	# import tables 
	# fileh = tables.open_file("test.h5", mode="r")
	# fileh.root.ScanData.Freq_Range
	# fileh.root.ScanData.Freq_Range[:]['Pinput_dB']
	# fileh.close()

if 0:
	#need to invoke %pylab
	fig1 = figure()
	ax1 = fig1.add_subplot(111)
	ax1.set_xlabel('Power in [mW]')
	Pout = np.abs(k.Sweep_Array['S21'][:,-1])*10**(k.Sweep_Array['Pinput_dB']/10.0)
	Pin = 10**(k.Sweep_Array['Pinput_dB']/10.0)
	line1 = ax1.plot(Pin,Pout, 'b-', label = 'Data')
	#could extend slope to index greater than 1
	slope = (Pout[1] - Pout[0])/(Pin[1]-Pin[0])
	ideal = slope*(Pin[:]-Pin[0]) + Pout[0]
	line2 = ax1.plot([Pin[0],Pin[-1]],[ideal[0],ideal[-1]] , 'r-', label = 'Ideal')
	ax1.set_ylabel('Power out [mW]', color='b')
	ax1.grid()
	show()

	correction_factor = ideal[:]/Pout[:]

	fig2 = figure()
	ax2 = fig2.add_subplot(111)
	ax2.set_xlabel('Freq [mW]')
	S21_dB_Measure = 10*np.log10(np.abs(k.Sweep_Array['S21'][-1,:]))
	S21_dB_Measure = 10*np.log10(np.abs(k.Sweep_Array['S21'][-1,:]))

if 0:

	def file_len(fname):
		'''count number lines in file'''
		with open(fname) as f:
			for i, l in enumerate(f):
				pass
		return i + 1

if 0:
	%pylab
	import tables 

	# fileh = tables.open_file("test.h5", mode="r")
	# fileh.root.ScanData.Freq_Range
	# fileh.root.ScanData.Freq_Range[:]['Pinput_dB']
	# fileh.close()

	#for g in fileh.walk_nodes(classname = 'Table'):
	#	print g

	#n._v_pathname
	l = [g._v_pathname for g in fileh.walk_nodes(classname = 'Table')]
	l = [g.attrs.Run for g in fileh.walk_nodes(classname = 'Table')]
	#for k in f:
	#	print k
	sweep_data_columns = np.dtype([("Fstart"         	, np.float32), ("Fstop"          	, np.float32), ("Heater_Voltage" 	, np.float32), ("Pinput_dB"      	, np.float32), ("Temperature"    	, np.float32),("S21"            	, np.complex128, (fsteps,)),("Frequencies"    	, np.float32,(fsteps,)), ])
	
	fileh = tables.open_file('44b_sing_res_TP_sweep.h5', mode = 'a')
	TOC = fileh.create_table('/', 'Contents', data_set_contents, "Table listing all data contained in h5 file", tables.Filters(0))
	TOC.append([('44b', '201404161723',1,2,3,'S1','ESAT4','/Run44b/201404161723')])
	#fileh.close()
	fileh.create_table('/Run44b','201405231723',description=sweep_data_columns,title = 'test of table creation',filters=tables.Filters(0), createparents=True)
	fileh.create_table(where, name, description=None, title='', filters=None, expectedrows=10000, chunkshape=None, byteorder=None, createparents=False, obj=None)
	fileh.get_node(TOC[1]['Path'])

if 0:
	import KAM
	reload(KAM)
	temp = KAM.thermometry()
	filename = '/Users/miguel_daal/Desktop/Some_Data/Run49a/TP_Sweep/Run49a_Temperatures'
	#filename = '/Users/miguel_daal/Desktop/Some_Data/TempData/Run44a_131219_Fix140627'

	temp.load_MonitoringVI_file(filename)

if 0: 
	import KAM
	reload(KAM)
	sweep = KAM.sweep()
	filename = '/Users/miguel_daal/Desktop/Some_Data/Calibrations/Cables_140520/Channel_1_Coax_2_50mK_KIDs_Run_50a_ScanData_37mK_2014520183338_Fixed20140625.mat'
	sweep.load_scandata(filename)
	index = 1 
	sweep.pick_loop(index)
	sweep.fit_cable_loss(Verbose = False)
	filename = '/Users/miguel_daal/Desktop/Some_Data/Run49a/TP_Sweep/49a_ScanData_45mK_2014420142743.mat'
	
	sweep._Temperature_Calibration = [(0.7, 0.602), (0.65,0.559), (0.6,0.502), (0.55,0.4456), (0.5,0.375), (0.45,0.3289), (0.4,0.290), (0.35,0.2524), (0.3, 0.2167), (0.25,0.184), (0.225,0.165), (0.2,0.1484), (0.175,0.1324), (0.15,0.1158), (0.1,0.0802), (0.0,0.0372)]
	sweep.load_scandata(filename)
	sweep.fill_sweep_array(Fit_Resonances = True, Compute_Preadout = True, Add_Temperatures = True)


if 0:
	import KAM
	reload(KAM)	
	Run51aP	= KAM.sweep(); Run51aP.load_hf5('/Run51a/T201411162028',filename = database_location);
	Run51aP.pick_loop(index)
	Run51aP.decompress_gain(Compression_Calibration_Index = -1, Show_Plot = False, Verbose = False)
	Run51aP.remove_cable_delay(Show_Plot = False, Verbose = False) 
	Run51aP.circle_fit(Show_Plot = False) 
	Run51aP.phase_fit(Fit_Method = 'Multiple',Verbose = True, Show_Plot = True)

if 0:
	import KAM
	reload(KAM)
	sweep = KAM.sweep()
	#filename = '/Users/miguel_daal/Desktop/Some_Data/Run44a/P_Sweep/44a_ScanData_60mK_20131210213718.mat' #p input issue	
	#filename = '/Users/miguel_daal/Desktop/Some_Data/Run51b/TP_Sweep/51b_ScanData_Merged_42mK_20141128.mat'
	#filename = '/Users/miguel_daal/Desktop/Some_Data/Run49a/TP_Sweep/49a_ScanData_45mK_2014420142743.mat'
	#filename = '/Users/miguel_daal/Desktop/Some_Data/Run49a/Survey/49a_ScanData_45mK_2014417175147.mat' #survey
	filename = '/Users/miguel_daal/Desktop/Some_Data/Run49a/P_Sweep/49a_ScanData_45mK_201442443323.mat' #P sweep
	sweep.load_scandata(filename)
	index = 0
	sweep.pick_loop(index)


if 0:
	import KAM
	reload(KAM)
	sweep = KAM.sweep()
	filename = '/Users/miguel_daal/Desktop/Some_Data/Run49a/TP_Sweep/49a_ScanData_45mK_2014420142743.mat'
	#filename = 'S5cellsize.s2p'
	

	#sweep.load_touchstone(filename)
	#sweep.load_hf5('40b_Single_Res_TP_Sweep.h5')
	#sweep.load_scandata('http://cosmology.berkeley.edu/~miguel/private/KIPS_Data/Data/Run33b/TP_Sweep/33b_ScanData_52mK_201172315038.mat')
	#sweep.load_scandata('http://cosmology.berkeley.edu/~miguel/private/KIPS_Data/Data/Run44b/Survey/44b_ScanData_40mK_20131218112528.mat')
	filename = '/Users/miguel_daal/Desktop/Some_Data/Calibrations/Cables_140520/Channel_1_Coax_2_50mK_KIDs_Run_50a_ScanData_37mK_2014520183338_Fixed20140625.mat'
	#filename = '/Users/miguel_daal/Desktop/Some_Data/Run48a/P_Sweep/48a_ScanData_45mK_201433112722.mat'
	sweep.load_scandata(filename)
	index = 1 
	sweep.pick_loop(index)
	sweep.fit_cable_loss(Verbose = False)
	filename = '/Users/miguel_daal/Desktop/Some_Data/Run44b/P_Sweep/44b_ScanData_60mK_2013121105756.mat' #S5 p sweep
	#filename = '/Users/miguel_daal/Desktop/Some_Data/Run48a/TP_Sweep/48a_ScanData_70mK_201433101142.mat'
	#filename = '/Volumes/STORE N GO/KIPS_Data/Run49a/TP_Sweep/49a_ScanData_45mK_2014420142743.mat'
	#filename = '/Volumes/STORE N GO/KIPS_Data/Run33b/TP_Sweep/33b_ScanData_52mK_201172315038.mat'
	
	sweep.load_scandata(filename)
	sweep.metadata.Atten_At_4K = 30
	sweep.metadata.Atten_NA_Output = 20
	sweep.Sweep_Array['Pinput_dB'] = sweep.Sweep_Array['Pinput_dB']+20
	
	index = 1 
	sweep.pick_loop(index)

	#sweep.plot_loop()
	#sweep.trim_loop(N = 5)
	#sweep.plot_loop()
	# Remove Cable Delay
	#Loop = sweep.remove_cable_delay(Loop, Show_Plot = False)

	# Fit loop to circle
	#Loop = sweep.circle_fit(Loop)

if 0: 
	import KAM
	reload(KAM)
	sweep = KAM.sweep()
	sweep.load_hf5('40b_Single_Res_TP_Sweep.h5')
	index = 1 
	sweep.pick_loop(index)

	# Remove Gain Compression
	sweep.decompress_gain(Compression_Calibration_Index = -1, Show_Plot = False)

	# Remove Cable Delay
	sweep.remove_cable_delay(Show_Plot = False)	

	# Fit loop to circle
	sweep.circle_fit(Show_Plot = True)

	# Fit resonance parameters
	sweep.phase_fit(Fit_Method = 'Multiple',Verbose = True, Show_Plot = True)

if 0:
	#Accessing sweep.Sweep_Array
	 s = sweep.Sweep_Array.view(np.recarray)
	 s.Temperature


	 s.dtype.names # see the names of the columns
	 #sweep.Sweep_Array.view(np.float64).reshape(sweep.Sweep_Array.shape + (-1,))


if 0:
	# import tables 
	# fileh = tables.open_file("test.h5", mode="r")
	# fileh.root.ScanData.Freq_Range
	# fileh.root.ScanData.Freq_Range[:]['Pinput_dB']
	# fileh.close()
	%pylab
	import KAM
	reload(KAM)
	k = KAM.sweep()
	k.load_hf5('40b_Single_Res_TP_Sweep.h5')
	index = 1
	S21 = k.Sweep_Array['S21'][index]
	Freq = k.Sweep_Array['Frequencies'][index]
	
	# Remove Gain Compression
	S21_Decompressed = k.decompress_gain(index, Compression_Calibration_Index = -1, Show_Plot = False)
	
	# Remove Cable Delay
	S21_Corrected = k.remove_cable_delay(Freq, S21_Decompressed, Show_Plot = False)

	# Fit loop to circle
	circle = k.circle_fit(Freq, S21_Corrected )


	#fig1           = plt.figure(figsize = (10,10))
	#ax2 = fig1.add_subplot(111, aspect='equal')
	

	# plot measured points with gain decompressed and cable delay removed
	#line1 = ax2.plot(S21_Corrected.real,S21_Corrected.imag,'g-', label = 'measured')


	# plot fit to measured points
	#pts = np.linspace(0, 2.0*np.pi, num=50, endpoint=True)
	#line2 = ax2.plot(circle.a + circle.r*np.cos(pts),circle.b + circle.r*np.sin(pts),'k-', label = ' fit to measured')
	


	

	def reject_outliers(data, m = 30.):
		''' data argument in is the resonance loop, a complex vector.
		this function cumputes the vector distance between adjavcent points
		compares the vector distance against its median (choosen becuase 
		median is less sensitive to outliers than mean).
		outputs a shortened data vector consisting of only those points which
		are a factor m less than the median and rejects points greater than
		a factor m from the median.'''
		adjacent_distance = np.abs(data[:-1]-data[1:])
		d = np.abs(adjacent_distance - np.median(adjacent_distance))
		mdev = np.median(d)
		s = d/mdev if mdev else 0
		mask = np.where(s<m, True, False)
		return np.extract(mask, data[:-1])
	#outliers_rejected = reject_outliers(S21_Corrected, m = 30.)
	#line3 = ax2.plot(outliers_rejected.real, outliers_rejected.imag,'r-', marker = '*', label = 'outliers rejected')
	#circle2,exit_code = k.circle_fit(Freq, outliers_rejected )
	#line4 = ax2.plot(circle2.a + circle2.r*np.cos(pts),circle.b + circle.r*np.sin(pts),'c-', label = 'fit to outliers rejected')

	


	#Rotate and center circle
	#fig2           = plt.figure(figsize = (10,10))
	#ax3 = fig2.add_subplot(111, aspect='equal')
	j = np.complex(0,1)
	ang = np.angle(S21_Corrected[0])
	circle.z = S21_Corrected#*np.exp(-j*(ang+np.pi/2))
	circle.freq = Freq
	zr = circle.a + j*circle.b
	z = circle.z
	f = circle.freq 
	#z =  (z - zr)
	offset_angle = np.angle(z[0]) + np.pi # seems to be better than np.angle(zr)
	z =  (z - zr)*np.exp(-j*offset_angle)
	#line1 = ax2.plot(z.real, z.imag,'r-', label = 'aligned with origin')
	#print('angle(zr) is ', np.angle(zr,deg = 1),'angle(z) is before rotation', np.angle(circle.z[0],deg = 1),'first and last angle', np.angle(z[0], deg = 1), ' last angle is  ',np.angle(z[-1], deg = 1))
	#ax3.legend(loc = 'best', fontsize=9)
	#ax2.legend(loc = 'best', fontsize=9)

	dx = S21_Corrected.real-circle.a
	dy = S21_Corrected.imag-circle.b
	circle_dist = np.sqrt(np.square(dx)+np.square(dy))-circle.r

	
	

	## Rotate circle to align with branch [-pi, pi]
	#j = np.complex(0,1)
	ang = np.angle(S21_Corrected[0])
	circle.z = S21_Corrected#*np.exp(-j*(ang+np.pi/2))
	circle.freq = Freq
	circle3  = k.phase_fit(circle)
	print('Q is ' + str(circle.Q))
	print('Qc is ' + str(circle.Qc))
	print('Qi is ' + str(circle.Qi))
	print('fr is ' + str(circle.fr))
	print('FMWH Est is ' + str(circle.FWHM_est))

	# def angle(z, deg = 0):
	# 	a = np.angle(z, deg = deg)
	# 	#s = (-np.sign(a)+1)/2.0
	# 	#s = np.vectorize(lambda a: 0.0 if np.sign(a) <= 0 else 1.0)
	# 	s = np.where(a<0,1,0)
	# 	units = 2*np.pi if deg == 0 else 360.0
	# 	return a + s*units

	# fig3           = plt.figure(figsize = (10,10))
	# ax5 = fig3.add_subplot(111)
	
	# # plot fit to measured points
	# pts = np.linspace(0, 2.0*np.pi, num=50, endpoint=True)
	# z = np.cos(pts)+j*np.sin(pts)
	# ang = angle(z,deg = True)
	# # plot measured points with gain decompressed and cable delay removed
	# line1 = ax5.plot(pts, ang,'g-', linewidth = 3,label = 'starting at 0')

	# ang = np.angle(z, deg = True)
	# line2 = ax5.plot(pts, ang,'k-', linewidth = 3,label = 'starting at 180')
	# ax5.legend(loc = 'best', fontsize=12)

	#line1 = ax2.plot(circle3.z.real,circle3.z.imag,'g.-')
	# fig3 = plt.figure(figsize = (6,6))
	# ax10 = fig3.add_subplot(111)
	# j = np.complex(0,1)
	# zr = circle.a + j*circle.b
	# z = circle.z
	# print('first and last angle', np.angle(z[0], deg = 1), np.angle(z[-1], deg = 1))
	# z =  (z - zr)*np.exp(-j*np.angle(zr))
	# print('first and last angle', np.angle(z[0], deg = 1), np.angle(z[-1], deg = 1))
	# #line5 = ax2.plot(z.real, z.imag,'y-', marker = '*')
	# line1 = ax10.plot(Freq,np.angle(z),'g-')
	# line2 = ax10.plot(Freq,np.arctan2(z.imag, z.real),'k-')
	# ang  = np.linspace(0,2*np.pi, 50)
	# x = array([  2.22142374e-01,   7.64094606e+08,   9.80506262e+00]) #x = np.array([theta,fr,Q])
	# line2 = ax10.plot(Freq,np.angle(z) + x[0] - 2.0*np.arctan(2.0*x[2]*(1-Freq/x[1])),'r-')
	
	#plt.show()
 
	


if 0:
	Sweep_Array_Record_Index = 2
	fig1           = plt.figure(figsize = (6,6))
	Freq           = k.Sweep_Array[Sweep_Array_Record_Index]['Frequencies']
	S21 		   = k.Sweep_Array[Sweep_Array_Record_Index]['S21']

	j = np.complex(0,1)
	S21_Corrected= np.exp(2*np.pi*Freq*j*90*10**-9)*S21

	#majorFormatter = FormatStrFormatter('%d')
	majormaxnlocator    = MaxNLocator(nbins = 5)
	minormaxnlocator    = MaxNLocator(nbins = 5*5)

	from scipy.optimize import minimize
	base = 0
	offset = -1

	def obj(t):
		S21a = np.exp(2*np.pi*Freq[base]*j*t)*S21[base]
		S21b = np.exp(2*np.pi*Freq[base+offset]*j*t)*S21[base+offset]
		return np.abs(S21a-S21b)
	out = minimize(obj,100*10**-9, method='Nelder-Mead')



	ax2 = fig1.add_subplot(111, aspect='equal')
	line2 = ax2.plot(S21.real,S21.imag, color='blue', linestyle='solid', linewidth = 3, label = 'Measured') 
	line1 = ax2.plot(S21_Corrected.real, S21_Corrected.imag, 'g-',linewidth = 3, label = 'Corrected')
	ax2.grid()
	ax2.set_title('Resonance Loop', fontsize=9)
	plt.setp(ax2.get_xticklabels(),rotation = 45)
	#ax2.legend(loc = 'best')

	fig1.subplots_adjust(wspace = 0.6,bottom = 0.09, top = 0.1)
	#fig1.suptitle('Run: {0}, Sensor: {1}, Ground Plane: {2}, Readout Power: {3} dBm, Date: {4}'.format(self.Run, self.Sensor,self.Ground_Plane,self.Sweep_Array[Sweep_Array_Record_Index]['Pinput_dB'],self.Time_Created), fontsize=10)
	#plt.tight_layout()
	plt.setp(fig1, tight_layout = True)
	plt.show()

if 0: 


	import numpy as np
	H00 = 8.
	H = -5.
	H11 = 3.

	# H00 = 1.
	# H = 2.
	# H11 = 3.


	L1 = ( H00 + H11 + np.sqrt(np.square(H11-H00) + 4*H*H) )/2.0
	L2 = ( H00 + H11 - np.sqrt(np.square(H11-H00) + 4*H*H) )/2.0

	e = (L1 - H00 ) / H


	Hess = np.array([[H00, H] , [H, H11]])
	e1 =  (1.0/np.sqrt(1+e*e)) * np.array([[1,e]]).T
	e2 =  (1.0/np.sqrt(1+e*e)) * np.array([[e,-1]]).T

	Q = np.array([e1,e2]).flatten().reshape((2,2))
	D = np.array([[L1, 0] , [0, L2]])

	print(Hess)
	print(Q.dot(D.dot(Q.T)))

if 0:
	import numpy.ma as ma
	f = f0 = circle.freq
	z = z0 = circle.z
	def angle(z, deg = 0):
		''' If z is a masked array. angle(z) returns the angle of the elements of z
		within the branch [0,360] instead of [-180, 180], which is the branch used
		in np.angle(). The mask of angle(z) is set to be the mask of the input, z.

		If z is not a masked array, then angle(z) is the same as np.angle except 
		that range is [0,360] instead of [-180, 180]

		If z is a vector, then an angle shift is added to z  so the z[0] is 0 degrees
		If z is a number, then dont shift angle'''
		a = np.angle(z, deg = deg)
		try:
			a = a - a[0] #if a is not a vector, then a[0] will throw an error
		except:
			pass
		p = np.where(a<=0,1,0)
		n = 2
		units = n*np.pi if deg == 0 else n*180
		try:
			a = ma.array(a + p*units,mask =z.mask) 
		except:
			a = a + p*units #if z is not a masked array do this
		return a
	z_theta = angle(z)
	#hessian
	def hess(x):
		theta,fr,Q = x	
		H = np.zeros((3,3), dtype = np.float)
		ff = (1-(f/fr))
		denom = (1+4.0*np.square(ff*Q))
		numer = (-theta+z_theta-2.0*np.arctan(2.0*ff*Q))
		H[0,0] = (2.0*np.ones_like(z_theta)).sum()
		H[0,1] = ((8.0*f*Q)/(np.square(fr)*denom)).sum()
		H[0,2] = ((8.0*ff)/denom).sum()
		H[1,0] = H[0,1] #((8.0*f*Q)/(np.square(fr)*denom)).sum()
		H[1,1] = (((32.0*np.square(f*Q))/(np.power(fr,4)*np.square(denom)))  +   ((64.0*np.square(f)*ff*np.power(Q,3)*numer)/(np.power(fr,4)*np.square(denom)))   +  ((16.0*f*Q*numer)/(np.power(fr,3)*denom))).sum()
		H[1,2] = (((32.0*f*Q*ff)/np.square(fr*denom))  +  ((64.0*f*np.square(ff*Q)*numer)/(np.square(fr*denom)))  - ((8.0*f*numer)/(np.square(fr)*denom))).sum()
		H[2,0] = H[0,2] #((8.0*ff)/denom).sum()
		H[2,1] = H[2,1] #(((32.0*f*ff*Q)/np.square(fr*denom))  +  ((64.0*f*np.square(ff*Q)*numer)/(np.square(fr*denom)))  -  ((8.0*f*numer)/(np.square(fr)*denom))).sum()
		H[2,2] = (((32.0*np.square(ff))/np.square(denom))  +  ((64.0*np.power(ff,3)*Q*numer)/np.square(denom))).sum()

		return H

	# {{2,
	# (8. f Q)/(fr^2 (1+4. (1-f/fr)^2 Q^2)),
	# (8. (1-f/fr))/(1+4. (1-f/fr)^2 Q^2)},



	
	# {(8. f Q)/(fr^2 (1+4. (1-f/fr)^2 Q^2)),
	# (32. f^2 Q^2)/(fr^4 (1+4. (1-f/fr)^2 Q^2)^2)+(64. f^2 (1-f/fr) Q^3 (-theta+z_theta-2. ArcTan[2. (1-f/fr) Q]))/(fr^4 (1+4. (1-f/fr)^2 Q^2)^2)+(16. f Q (-theta+z_theta-2. ArcTan[2. (1-f/fr) Q]))/(fr^3 (1+4. (1-f/fr)^2 Q^2)),
	# (32. f (1-f/fr) Q)/(fr^2 (1+4. (1-f/fr)^2 Q^2)^2)+(64. f (1-f/fr)^2 Q^2 (-theta+z_theta-2. ArcTan[2. (1-f/fr) Q]))/(fr^2 (1+4. (1-f/fr)^2 Q^2)^2)-(8. f (-theta+z_theta-2. ArcTan[2. (1-f/fr) Q]))/(fr^2 (1+4. (1-f/fr)^2 Q^2))},
	

	
	# {(8. (1-f/fr))/(1+4. (1-f/fr)^2 Q^2),
	# (32. f (1-f/fr) Q)/(fr^2 (1+4. (1-f/fr)^2 Q^2)^2)+(64. f (1-f/fr)^2 Q^2 (-theta+z_theta-2. ArcTan[2. (1-f/fr) Q]))/(fr^2 (1+4. (1-f/fr)^2 Q^2)^2)-(8. f (-theta+z_theta-2. ArcTan[2. (1-f/fr) Q]))/(fr^2 (1+4. (1-f/fr)^2 Q^2)),
	# (32. (1-f/fr)^2)/(1+4. (1-f/fr)^2 Q^2)^2+(64. (1-f/fr)^3 Q (-theta+z_theta-2. ArcTan[2. (1-f/fr) Q]))/(1+4. (1-f/fr)^2 Q^2)^2}}
	#jac
# def jac(x):
# 	theta,fr,Q = x
# 	J = np.zeros((3,),dtype = np.float)    #np.zeros_like(x)
# 	ff = (1-(f/fr))
# 	denom = (1+4.0*np.square(ff*Q))
# 	numer = (-theta+z_theta-2.0*np.arctan(2.0*ff*Q))	
# 	J[0] = (-2.0*numer).sum()
# 	J[1] = (-8.0*f*Q*numer/(np.square(fr)*denom)).sum()
# 	J[2] = (-8.0*ff*numer/denom).sum()
# 	return J


	def jac(x):
		theta,fr,Q = x
		J = np.zeros((3,),dtype = np.float)    #np.zeros_like(x)
		ff = (1-(f/fr))
		denom = (1+4.0*np.square(ff*Q))
		numer = (-theta+z_theta-2.0*np.arctan(2.0*ff*Q))	
		J[0] = np.sum(-2.0*numer)
		J[1] = np.sum(-8.0*f*Q*numer/(np.square(fr)*denom))
		J[2] = np.sum(-8.0*ff*numer/denom)
		return J	
		#{-2 (-theta+z_theta-2. ArcTan[2. (1-f/fr) Q]),
		#-((8. f Q (-theta+z_theta-2. ArcTan[2. (1-f/fr) Q]))/(fr^2 (1+4. (1-f/fr)^2 Q^2))),
		#-((8. (1-f/fr) (-theta+z_theta-2. ArcTan[2. (1-f/fr) Q]))/(1+4. (1-f/fr)^2 Q^2))}

	def obj(x):
		theta,fr,Q = x
		return np.square(z_theta - theta - 2.0*np.arctan(2.0*Q*(1-f/fr))).sum()	


if 0:
	database_location = 'Data/My_Data_Library.h5'
	import KAM
	reload(KAM)	

	index = 7
	#52 sweeps - some very nonlinear
	sweep     = KAM.sweep(); sweep.load_hf5('/Run48a/T201403311119', filename = database_location); sweep.metadata.width = 8;
	
	sensor_ids = np.array(['S1','S2','S3','S4','S5','S6','S7','S8','S9','S10','S11','S12','S13','S14','S15','S16'])
	Z3 = np.array([85.7779239,	67.8250245,	50.1762772,	33.824545,	21.2469277,	12.7273743,	7.18826586,	3.5793348,	78.4335348,	61.6228064,	45.6375047,	31.5852207,	20.407557,	12.372514,	7.10001542,	3.89603542])
	Z3_dict_1 = dict(zip(sensor_ids,Z3))

	Z1 = np.array([52.1559515,52.1558281,52.1560869,52.1561139,52.1483422,52.144045,52.1437542,52.0581491,51.2646322,51.2662686,51.2663971,51.2663751,51.2663306,51.266291,51.2661294, 51.2656037])
	Z1_dict_1 = dict(zip(sensor_ids,Z1))

	Eeff = np.array([4.19652819,	3.81480738,	3.25172475,	2.61741572,	2.09048564,	1.70180979,	1.44820567,	1.27737833,	4.0067732,	3.60877767,	3.11707476,	2.590019,	2.10964846,	1.73077079,	1.46394603,	1.29009339])
	Eeff_dict_1 = dict(zip(sensor_ids,Eeff))

	ground_plane_wafer = np.array(['DSAT3','DSAT4','DSAT5','DSAT6','DSAT7','GSAT1', 'HSA2'])
	ground_plane_wafer_thickness = np.array([348.0,	309.0,	309.0,	164.0,	85.0,	305.5,	265.33])
	gp_thickness_dict_1 = dict(zip(ground_plane_wafer,ground_plane_wafer_thickness))


	def _set_metadata(Z1_dict,Z3_dict,Eeff_dict,gp_thickness_dict):
		def _extract_wafer_label(string_input):
			'''returns first word in string for which all cased characters are upper case are AND for which the word is entirely 
			alpha numeric (no '-', '(', etc) AND for which word is >= 4 characters. returns warning if there are two matches or no matches.
			'''
			
			matches = 0
			wafer_label = None
			split_string = string_input.replace('(','|').replace(')','|').replace(' ','|').split('|')[::-1] # reversed so that first occurance comes last
			for word in split_string:
				if word.isalnum() and word.isupper() and len(word) >= 4:
					wafer_label = word
					matches = matches + 1
			if matches > 1:
				warnings.warn('More than one wafer label found. Using first match.')
			if matches == 0:
				warnings.warn('No wafer label matches found. Returning None')

			return wafer_label

		def _extract_sensor_id():
			sensor = sweep.metadata.Sensor
			wafer_label  = _extract_wafer_label(sensor)

			split_string  = sensor.replace(wafer_label ,'').split()
			matches = 0
			sensor_id = None
			for word in split_string:
				if word.isalnum() and word.isupper() and len(word) <= 4:
					sensor_id = word
					matches = matches + 1
			if matches > 1:
				warnings.warn('More than one sensor id found. Using first match.')
			if matches == 0:
				warnings.warn('No sensor id matches found. Returning None')

			return sensor_id

			

		def _extract_width():
			''' extracts resonator width from sweep.metadata.Sensor,'''
			sensor = sweep.metadata.Sensor
			e = sensor.rfind('um')
			s = e - 1
			while True:
				if sensor[s-1].isdigit() is True:
					s = s -1;
				else:
					break
			width  = int(sensor[s:e])
			return width	




		gid = _extract_wafer_label(sweep.metadata.Ground_Plane)
		sid = _extract_sensor_id()
		sweep.metadata.Resonator_Width = _extract_width()*1e-6 # in meters
		sweep.metadata.Resonator_Thickness =  200*1e-9 #list if more than one
		sweep.metadata.Resonator_Impedance = Z3_dict[sid]
		sweep.metadata.Resonator_Eeff = Eeff_dict[sid] # Resonator Dielectric Constant
		sweep.metadata.Through_Line_Impedance = Z1_dict[sid]
		sweep.metadata.Ground_Plane_Thickness = gp_thickness_dict[gid]*1e-9

	_set_metadata(Z1_dict_1,Z3_dict_1,Eeff_dict_1,gp_thickness_dict_1)



if 0:
	database_location = 'Data/My_Data_Library.h5'
	import KAM
	reload(KAM)	
	
	
	# sweep.decompress_gain(Compression_Calibration_Index = -1, Show_Plot = False, Verbose = False)
	# sweep.remove_cable_delay(Show_Plot = False, Verbose = False) 
	# sweep.circle_fit(Show_Plot = False) 
	# sweep.phase_fit(Fit_Method = 'Multiple',Verbose = True, Show_Plot = True)	
	
	index = 7
	#sweep     = KAM.sweep(); sweep.load_hf5('/Run46a/T201402262113', filename = database_location); sweep.metadata.width = 256
	
	#has an outlier curve - very nonlinear resonator
	sweep     = KAM.sweep(); sweep.load_hf5('/Run45a/T201402061732', filename = database_location); sweep.metadata.width =64; sweep.metadata.custom = [True,'', '-']# to high power
	
	#this one is blurred by mirophonics
	#sweep     = KAM.sweep(); sweep.load_hf5('/Run45b/T201402062055', filename = database_location); sweep.metadata.width = 128;

	#this one show very clear loop squashing
	#sweep    = KAM.sweep(); sweep.load_hf5('/Run46a/T201402211440', filename = database_location); 

	#52 sweeps - some very nonlinear
	#sweep     = KAM.sweep(); sweep.load_hf5('/Run48a/T201403311119', filename = database_location); sweep.metadata.width = 8;
	

	#run 51a survey -- index must be 0!
	#sweep    = KAM.sweep(); sweep.load_hf5('/Run51a/T201411161833', filename = database_location); index = 0 

	#run 52b survey -- index must be 0! (Low freq survey)
	#sweep    = KAM.sweep(); sweep.load_hf5('/Run52b/T201503112206', filename = database_location); index = 0 

	#run 52b survey -- index must be 0! (High freq survey)
	#sweep    = KAM.sweep(); sweep.load_hf5('/Run52b/T201502262156', filename = database_location); index = 0

	#false data /RunF1/T201505011200
	#sweep    = KAM.sweep(); sweep.load_hf5('/RunF1/T201505011200', filename = database_location);

	sweep.pick_loop(index)
	#sweep.metadata.Electrical_Delay = None
	#sweep.remove_cable_delay(Show_Plot = False)#center_freq = 700e6)
	#x = sweep.nonlinear_fit()


	# index = 143
	# filename = path + 'Run48b/TP_Sweep/48b_ScanData_45mK_201441101927.mat'	
	# sweep.load_scandata(filename)
	# sweep.metadata.Sensor = 'S5 FHN1 (32um width)'
	# _set_metadata(Z1_dict_1,Z3_dict_1,Eeff_dict_1,gp_thickness_dict_1)
	# sweep.pick_loop(index)

	# sweep.decompress_gain(Compression_Calibration_Index = -1, Show_Plot = False, Verbose = True)
	# sweep.remove_cable_delay(Show_Plot = False, Verbose = False)
	# sweep.circle_fit(Show_Plot = False)
	# sweep.phase_fit()
if 0:
	database_location = 'Data/My_Data_Library.h5'
	%pylab
	%run -i  Gen_Data.py
	sweep.save_hf5( filename = database_location, overwrite = True)
	index = 7

	sweep.pick_loop(index)
	#x = sweep.nonlinear_fit()
if 0:
	import KAM
	reload(KAM)

	from scipy.interpolate import interp1d

	sweep    = KAM.sweep(); sweep.load_hf5('/Run51a/T201411161833', filename = database_location); index = 0
	sweep.pick_loop(index)
	sweep.remove_cable_delay()
	sweep.pick_loop(index)
	tau = sweep.metadata.Electrical_Delay #sec
	tau_bandwidth = 1/tau #Hz - Estimate of winding bandwith using tau
	center_freq = 700e6 #Hz

	S21 = sweep.loop.z
	f = sweep.loop.freq
	closest_index_to_center_freq = np.where(np.abs(f-center_freq) == np.abs(f-center_freq).min()) 
	S21 = S21*np.exp(np.complex(0,-np.angle(S21[closest_index_to_center_freq]))) #rotate circle so that S21[center_freq] is close to positive x axis, and angle(S21[center_freq]) ~ 0
	
	
	condition = ((center_freq - .30*tau_bandwidth) < f) & (f<center_freq+.30*tau_bandwidth)
	f_lower_band =np.extract(condition,f)
	S21_lower_band = np.extract(condition,S21)
	ang_lower_band = np.extract(condition,np.angle(S21)) #np.angle has range [+pi,-pi]
	interp_lower_band = interp1d(ang_lower_band, f_lower_band,kind='linear')
	lower_x_axis_crossing_freq = interp_lower_band(0).item()

	center_freq = center_freq + tau_bandwidth #shift to upper band
	condition = ((center_freq - .30*tau_bandwidth) < f) & (f<center_freq+.30*tau_bandwidth)
	f_upper_band =np.extract(condition,f)
	S21_upper_band = np.extract(condition,S21)
	ang_upper_band = np.extract(condition,np.angle(S21)) #np.angle has range [+pi,-pi]
	interp_upper_band = interp1d(ang_upper_band, f_upper_band,kind='linear')
	upper_x_axis_crossing_freq = interp_upper_band(0).item()

	winding_bandwidth = upper_x_axis_crossing_freq - lower_x_axis_crossing_freq

	tau_winding = 1/winding_bandwidth

	print tau_winding


	fig = plt.figure( figsize=(5, 5), dpi=150)
	ax = {}
	ax[1] = fig.add_subplot(2,1,1)
	ax[2] = fig.add_subplot(2,1,2, aspect = 'equal')
	curve = ax[1].plot(f_lower_band,ang_lower_band, linestyle = '-')
	curve = ax[1].plot(f_upper_band,ang_upper_band, linestyle = '-')
	curve = ax[2].plot(S21_lower_band.real,S21_lower_band.imag, linestyle = '-')
	curve = ax[2].plot(S21_upper_band.real,S21_upper_band.imag, linestyle = '-')
	plt.show()

if 0:
	database_location = 'Data/My_Data_Library.h5'
	import KAM
	reload(KAM)	
	sweep  = KAM.sweep();  

	sweep.load_hf5('/Run45a/T201402061732', filename = database_location);


	index = 11
	def fit(index,sweep):
	    sweep.pick_loop(index)
	    sweep.decompress_gain(Compression_Calibration_Index = -1, Show_Plot = False, Verbose = False)
	    sweep.normalize_loop()
	    sweep.remove_cable_delay(Show_Plot = False, Verbose = True,Force_Recalculate = False) 
	    sweep.circle_fit(Show_Plot = True) 
	    sweep.phase_fit(Fit_Method = 'Multiple',Verbose = True, Show_Plot = True)


	Readout_Dict = {}

	F = [409600000., 509500000, 609400000, 709300000, 809200000, 909100000, 1009000000]
	G = [48.2976, 48.1631, 48.0342, 47.684, 47.3322, 46.9015, 46.4087]
	Nm = [5.48601,5.72677,5.77245,6.0146,5.94466,5.95258,6.13591]
	Np = Nm
	P1dB = -48.
	Readout_Dict['SiGe #2'] = dict(freq =F,g= G,Tn_m = Nm,Tn_p = Np,P1dB= P1dB)

	F = [400000000., 500000000, 600000000, 700000000, 800000000, 900000000, 1000000000]
	G = [47.5, 47.3, 47.0, 46.6, 46.0, 45.6, 45.0]
	Nm = [5.7, 6.3, 6.1, 6.3, 6.6, 6.6, 7.0]
	Np = Nm
	P1dB = -48.
	Readout_Dict['SiGe #1'] = dict(freq =F,g= G,Tn_m = Nm,Tn_p = Np,P1dB= P1dB)

	F = [400000000., 500000000, 600000000, 700000000, 800000000, 900000000, 1000000000]
	G = [31.6958, 31.7332, 33.3491, 34.582, 36.4723, 35.4597, 35.4288]
	Nm = [10.0454, 9.13519, 8.59369, 8.28292, 8.11164, 7.86398, 7.5084]
	Np = Nm
	P1dB = -40.
	Readout_Dict['InP #2'] = dict(freq =F,g= G,Tn_m = Nm,Tn_p = Np,P1dB= P1dB)

	F = [395000000.,424500000, 454000000, 483500000, 513000000, 542500000, 572000000, 601500000, 631000000, 660500000, 690000000, 719500000, 749000000, 778500000, 808000000, 837500000, 867000000, 896500000, 926000000, 955500000, 985000000]
	Nm = [488.6053076, 489.2697104, 474.3872914, 473.1617407, 467.3813032, 470.0790808, 460.311823, 446.0557503, 439.5120869, 439.2718329, 429.4232912, 423.771945, 414.857644, 419.2513872, 410.1854824, 401.0360685, 398.6567012, 400.5274794, 389.6199922, 390.1977107, 411.6113207]
	G = [ 39.1,  39.1,  39.1,  39. ,  39. ,  39. ,  39. ,  38.9,  38.9, 38.9,  38.8,  38.7,  38.7,  38.6,  38.6,  38.5,  38.4,  38.4, 38.3,  38.2,  38.1]
	Np = Nm
	P1dB = -11.2 # at input
	Readout_Dict['AML016P3411'] = dict(freq =F,g= G,Tn_m = Nm,Tn_p = Np,P1dB= P1dB)

	F = [3000000., 3000000000]
	G = [1.,1]
	Nm = [120743991885170.77,120743991885170.77]#rms Peak Voltage Noise
	Np = Nm
	P1dB = +20. # Fault power level. 
	Readout_Dict['NA']  = dict(freq =F,g= G,Tn_m = Nm,Tn_p = Np,P1dB= P1dB)


	sweep.metadata.Readout_Dict = Readout_Dict
	sweep.metadata.Digitizer = 'NA'
	fit(index,sweep)


	def plot_fit(R = 0,tau = 0):
		S21 = sweep.Sweep_Array[index]['S21']
		F = sweep.Sweep_Array[index]["Frequencies"]
		s,t,u,g,x = sweep.chi_square()
		s21 =  np.vectorize(s)
		z = s21(F)*np.exp(np.complex(0.,R))* np.exp(np.complex(0,-2*np.pi*tau)*F)
		fig = plt.figure( figsize=(6.5, 6.5), dpi=100)
		ax = fig.add_subplot(111,aspect='equal')
		line = ax.plot(S21.real,S21.imag,'bo', label = 'Original Data')
		line = ax.plot(z.real,z.imag,'ro', label = 'Primary Fit')

		# num 11 run 45a, chi squared 39901
		#x = np.array([ np.complex(-2.71548272e-01,-0.80447015), np.complex(1.00782510e-07,0.) , np.complex(1.16375424e+05,0.), np.complex(4.32088382e+05,0.),np.complex(6.64759813e+08,0.), np.complex(-1.09128025e-01,0.)  ])
		# num 8 run 45a, chi squared 22663
		#x = np.array([ np.complex(-2.81539665e-01,-0.77691904), np.complex(1.00782510e-07,0.) , np.complex(1.31034209e+05,0.), np.complex(3.54867553e+05,0.) ,np.complex(6.64764400e+08,0.), np.complex(-1.47657166e-02,0.) ])
		# num 0 run 45a, chi squared  693
		#x = np.array([ np.complex(-2.95832897e-01,-0.73027548), np.complex(1.00782510e-07,0.) ,np.complex(1.50631220e+05,0.)  ,  np.complex(3.18966486e+05,0.) , np.complex(6.64768336e+08,0. ) , np.complex(1.33061244e-01,0.) ])
		# num 9 run 45a, chi squared  29195
		#x = np.array([ np.complex(-2.81846369e-01,-0.78787097),   np.complex(9.47642903e-08,0)  ,np.complex(1.23896077e+05,0)        ,   np.complex(3.68141450e+05,0)        , np.complex(6.64763039e+08,0)        ,  np.complex(-4.68587128e-02,0)        ])
		s_fit = lambda f: sweep.loop.normalization * np.exp(np.complex(0.,angle(x[0]))) * np.exp(np.complex(0,-2*np.pi*x[1])*f) * (1 - (x[2]/x[3])*np.exp(np.complex(0,-x[5])) / np.complex(1, 2*x[2]*(f-x[4])/x[4]))
		S = np.vectorize(s_fit)
		line = ax.plot(S(F).real,S(F).imag,'go', label = 'Secondary Fit')
		ax.legend(loc = 'best', fontsize=9,scatterpoints =1, numpoints = 1, labelspacing = .02) 
		ax.set_xlabel(r'$\Re[S_{21}(f)]$')
		ax.set_ylabel(r'$\Im[S_{21}(f)]$')
		ax.yaxis.labelpad = -6
		fig.savefig('Loop_Run_{0}_Index_{1}'.format(sweep.metadata.Run, index), dpi = 300, transparency  = True)
		#ax.set_title('Run: {0}; Sensor: {1}; Ground: {2}; Record Date: {3}'.format(sweep.metadata.Run, sweep.metadata.Sensor, sweep.metadata.Ground_Plane, sweep.metadata.Time_Created),fontsize=10)
		return x

if 0:

	database_location = 'Data/My_Data_Library.h5'
	import KAM
	reload(KAM)	
	sweep  = KAM.sweep();  
	sweep.load_hf5('/Run45a/T201402061732', filename = database_location);
	# SC = sweep.metadata.Readout_Dict

	# fig = plt.figure( figsize=(5,5))#, dpi=150)
	# ax = fig.add_subplot(111)

	# for key in SC.keys():
	# 	print key
	# 	ax.plot(SC[key]['freq'], SC[key]['g'], 'o')
	# 	deg =  min(len(SC[key]['freq']) - 2,9) if len(SC[key]['freq']) >2 else len(SC[key]['freq']) - 1
		

	# 	#coefs = numpy.polynomial.chebyshev.chebfit(SC[key]['freq'],  SC[key]['g'], deg)
	# 	coefs = numpy.polynomial.polynomial.polyfit(SC[key]['freq'],  SC[key]['g'], deg)
	# 	x_sam = linspace(SC[key]['freq'][0], SC[key]['freq'][-1], num=100)
	# 	#ax.plot(x_sam, numpy.polynomial.chebyshev.chebval(x_sam,coefs),'-')
	# 	ax.plot(x_sam, numpy.polynomial.polynomial.polyval(x_sam,coefs),'-')
	# plt.show()

	SC = sweep.metadata.System_Calibration
	for key in SC.keys():
		print key, '  ', SC[key].keys()

	sweep.fit_system_calibration()

	SC = sweep.metadata.System_Calibration
	for key in SC.keys():
		print key, '  ', SC[key].keys()

	sweep.fit_system_calibration()

	SC = sweep.metadata.System_Calibration
	for key in SC.keys():
		print key, '  ', SC[key].keys()

	fig = plt.figure( figsize=(5,5))#, dpi=150)
	ax = fig.add_subplot(111)

	for key in SC.keys():
		print key
		ax.plot(SC[key]['freq'], SC[key]['g'], 'o')
		#deg =  min(len(SC[key]['freq']) - 2,9) if len(SC[key]['freq']) >2 else len(SC[key]['freq']) - 1
		

		#coefs = numpy.polynomial.chebyshev.chebfit(SC[key]['freq'],  SC[key]['g'], deg)
		#coefs = numpy.polynomial.polynomial.polyfit(SC[key]['freq'],  SC[key]['g'], deg)
		x_sam = linspace(SC[key]['freq'][0], SC[key]['freq'][-1], num=100)
		ax.plot(x_sam, numpy.polynomial.chebyshev.chebval(x_sam,SC[key]['g_fit']),'-')
		#ax.plot(x_sam, numpy.polynomial.polynomial.polyval(x_sam,SC[key]['g_fit']),'-')
	plt.show()

if 0:
	database_location = 'Data/My_Data_Library.h5'
	import KAM
	reload(KAM)	
	sweep  = KAM.sweep();  
	sweep.load_hf5('/Run45a/T201402061732', filename = database_location);

	sweep.loop.index = 0
	F = sweep.Sweep_Array[sweep.loop.index]['Frequencies']

	cable_order = ['4K_to_40mK', '300K_to_4K', 'One_Way_300K'] # first , second, third cable stretches

	CC = sweep.metadata.Cable_Calibration
	cable_g = []
	for i in xrange(len(cable_order)):
		cable_g.append(CC[cable_order[i]][0]*np.sqrt(F)+CC[cable_order[i]][1]*F+CC[cable_order[i]][2])

if 0: #Development of Complete Fit function
	database_location = 'Data/My_Data_Library.h5'
	import KAM
	reload(KAM)	
	sweep  = KAM.sweep();  

	sweep.load_hf5('/Run45a/T201402061732', filename = database_location);


	index = 0
	def fit(index,sweep):
	    sweep.pick_loop(index)
	    sweep.decompress_gain(Compression_Calibration_Index = -1, Show_Plot = False, Verbose = False)
	    sweep.normalize_loop()
	    sweep.remove_cable_delay(Show_Plot = False, Verbose = False,Force_Recalculate = False) 
	    sweep.circle_fit(Show_Plot = False) 
	    sweep.phase_fit(Fit_Method = 'Multiple',Verbose = False, Show_Plot = False)
	fit(index,sweep)


	a,b = sweep.loop.a,sweep.loop.b
	tau = sweep.metadata.Electrical_Delay
	Q = sweep.loop.Q 
	Qc = sweep.loop.Qc 
	fr = sweep.loop.fr 
	phi = (sweep.loop.phi * np.pi/180) + 0*np.pi
	s21_  = lambda f: sweep.loop.normalization * np.exp(np.complex(0.,angle(np.complex(a,b)))) * np.exp(np.complex(0,-2*np.pi*f*tau)) * (1 - (Q/Qc)*np.exp(np.complex(0,-phi)) / np.complex(1, 2*Q*(f-fr)/fr))
	s21 =  np.vectorize(s21_)


	def plot_fit(R = 0,tau = 0):
		S21 = sweep.Sweep_Array[index]['S21']
		F = sweep.Sweep_Array[index]["Frequencies"]
		x = sweep.complete_fit()                       # <<<<<-------------
		
		z = s21(F)*np.exp(np.complex(0.,R))* np.exp(np.complex(0,-2*np.pi*tau)*F)
		fig = plt.figure( figsize=(6.5, 6.5), dpi=100)
		ax = fig.add_subplot(111,aspect='equal')
		line = ax.plot(S21.real,S21.imag,'bo', label = 'Original Data')
		line = ax.plot(z.real,z.imag,'ro', label = 'Primary Fit')

		# num 11 run 45a, chi squared 39901
		#x = np.array([ np.complex(-2.71548272e-01,-0.80447015), np.complex(1.00782510e-07,0.) , np.complex(1.16375424e+05,0.), np.complex(4.32088382e+05,0.),np.complex(6.64759813e+08,0.), np.complex(-1.09128025e-01,0.)  ])
		# num 8 run 45a, chi squared 22663
		#x = np.array([ np.complex(-2.81539665e-01,-0.77691904), np.complex(1.00782510e-07,0.) , np.complex(1.31034209e+05,0.), np.complex(3.54867553e+05,0.) ,np.complex(6.64764400e+08,0.), np.complex(-1.47657166e-02,0.) ])
		# num 0 run 45a, chi squared  693
		#x = np.array([ np.complex(-2.95832897e-01,-0.73027548), np.complex(1.00782510e-07,0.) ,np.complex(1.50631220e+05,0.)  ,  np.complex(3.18966486e+05,0.) , np.complex(6.64768336e+08,0. ) , np.complex(1.33061244e-01,0.) ])
		# num 9 run 45a, chi squared  29195
		#x = np.array([ np.complex(-2.81846369e-01,-0.78787097),   np.complex(9.47642903e-08,0)  ,np.complex(1.23896077e+05,0)        ,   np.complex(3.68141450e+05,0)        , np.complex(6.64763039e+08,0)        ,  np.complex(-4.68587128e-02,0)        ])
		
		s_fit = lambda f: sweep.loop.normalization * np.exp(np.complex(0.,angle(np.complex(x[0],x[1])))) * np.exp(np.complex(0,-2*np.pi*x[2])*f) * (1 - (x[3]/x[4])*np.exp(np.complex(0,-x[6])) / np.complex(1, 2*x[3]*(f-x[5])/x[5]))
		S = np.vectorize(s_fit)
		line = ax.plot(S(F).real,S(F).imag,'go', label = 'Secondary Fit')
		ax.legend(loc = 'best', fontsize=9,scatterpoints =1, numpoints = 1, labelspacing = .02) 
		ax.set_xlabel(r'$\Re[S_{21}(f)]$')
		ax.set_ylabel(r'$\Im[S_{21}(f)]$')
		ax.yaxis.labelpad = -6
		fig.savefig('Loop_Run_{0}_Index_{1}'.format(sweep.metadata.Run, index), dpi = 300, transparency  = True)
		#ax.set_title('Run: {0}; Sensor: {1}; Ground: {2}; Record Date: {3}'.format(sweep.metadata.Run, sweep.metadata.Sensor, sweep.metadata.Ground_Plane, sweep.metadata.Time_Created),fontsize=10)


		return x
	plot_fit()


if 0:
	Ver = 2
	%run -i Load_Datasets.py


	##Run45aP #64um
	##Run45bP #128um
	##Run48aP #8um
	##Run49aP #4um


	# # Perform Nonlinear Fits and Save figures
	index = 0 
	Run45aP.pick_loop(index)
	fit, fig, ax = Run45aP.nonlinear_fit(Save_Fig = True)

	##Not Good
	## Run45bP.pick_loop(index) #invalid values in sqrt
	## Run45bP.nonlinear_fit(Save_Fig = True)

	##Not Good
	##Run48aP.pick_loop(index)
	##Run48aP.nonlinear_fit(Save_Fig = True,Indexing = (None,-9,3))

	# Run49aP.pick_loop(index)
	# Run49aP.nonlinear_fit(Save_Fig = True, Indexing = (None,None,10))

	# Run44aP.pick_loop(index)
	# Run44aP.nonlinear_fit(Save_Fig = True,Indexing = (None,-5,None))


	# Run46aPl.pick_loop(index)
	# Run46aPl.nonlinear_fit(Save_Fig = True,Indexing = (None,None,None))
	Run45aP.pick_loop(index)
	cfit = Run45aP.complete_fit( Use_Mask = True, Verbose = False, Show_Plot = True, Save_Fig = True,Sample_Size = m)



	#Construct Simulated data for run  Run45aP, then non-linear fit it, then construct sweep array including Concurrent and Stepwise fits and save
	bestfit = 'Powell'
	Zfl = Run45aP.metadata.Feedline_Impedance
	Zres = Run45aP.metadata.Resonator_Impedance
	V30V30 = fit['V30V30']
	eta = fit[bestfit].x[4]
	delta =  fit[bestfit].x[5]
	f0 = fit[bestfit].x[0]
	Qi = fit[bestfit].x[1]
	Qc = fit[bestfit].x[2]
	phi31 = fit[bestfit].x[3]
	# use noise calculated from complete fit
	Amplitude_Noise_Variance = cfit['sigma_squared_m'][0]
	Phase_Noise_Variance = cfit['sigma_squared_p'][0]

	import KAM
	reload(KAM)	
	sweep  = KAM.sweep();

	sweep.generate_nonlinear_data(Show_Plot = True, Phase_Noise_Variance = None, Amplitude_Noise_Variance = None, Like = Run45aP,
		curve_parameter_dict = {'f_0':f0, 'Qtl':Qi, 'Qc':Qc, 'eta':eta, 'delta':delta, 'Zfl':Zfl, 'Zres':Zres, 'phi31': phi31, 'phiV1':0, 'V30V30':V30V30 },
		sweep_parameter_dict = {'Run': 'Mock_45a', 'Pprobe_dBm_Start' :-100.0,'Pprobe_dBm_Stop': -54.0, 'Pprobe_Num_Points':17, 'numBW':40,'num': 2000, 'Up_or_Down': 'Up', 'Freq_Spacing':'Linear'})

	sweep.nonlinear_fit(Save_Fig = True,Indexing = (None,None,None))



	sweep.fill_sweep_array(Fit_Resonances = True, Compute_Preadout = False, Add_Temperatures = False,Complete_Fit = True )


	sweep.save_hf5(overwrite = True)	





	
 # 	def fit(sweep):
	# 	sweep.decompress_gain(Show_Plot = False, Verbose = False)
	# 	sweep.normalize_loop()
	# 	sweep.remove_cable_delay(Show_Plot = False, Verbose = False) 
	# 	sweep.circle_fit(Show_Plot = False) 
	# 	sweep.phase_fit(Show_Plot = False, Verbose = False)

	# ## Draw loops for Run45aP Data
	for index in [0,8,9,11]:
		m = 100
		print "plotting index {}".format(index)
		Run45aP.pick_loop(index)
		#fit(Run45aP)
		fit = Run45aP.complete_fit( Use_Mask = True, Verbose = False, Show_Plot = True, Save_Fig = True,Sample_Size = m)
		print 'chi^2: MP - {0}, G - {1} with m = {2}'.format(fit['cPowell'].fun, fit['sPowell'].fun,m)


	### Draw loops for Simulated Run45aP Data
	for index in [0,8,9,11]:
		Run45aP_Mock.pick_loop(index)
		#fit(Run45aP_Mock)
		Run45aP_Mock.complete_fit( Use_Mask = True, Verbose = False , Show_Plot = True, Save_Fig = True)


if 1: #test code for generating resonance loops
	import KAM
	reload(KAM)	
	sweep  = KAM.sweep();

	sweep.metadata.Electrical_Delay =  tau=0.
	sweep.loop.index = 0 
	sweep.loop.freq = freq = np.linspace(699.99e6, 700.01e6,8000)
	fr = 700.e6
	Qc = 500.e3
	Q = 300.e3
	#sweep.loop.r = Q/Qc
	#sweep.loop.a = a = 1
	#sweep.loop.b = b= .1
	#sweep.loop.normalization = norm =  np.abs(np.complex(a,b))
	R = 10
	phi = (np.pi/180) * 10
	theta = (np.pi/180) * 179
	print 'phi is {}, and theta is {}'.format(phi*180/np.pi, theta*180/np.pi)

	sweep.loop.z = z = R* np.exp(np.complex(0,theta))*np.exp(np.complex(0,-2*np.pi*tau)*freq) * (1 - (Q/Qc)*np.exp(np.complex(0,phi)) / (1 + np.complex(0,2*Q)*(freq-fr)/fr ) )
	#np.exp(np.angle(np.complex(a,b))) #norm *np.exp(np.complex(0,np.angle(np.complex(a,b))))*  44 (1/1)*np.complex(a,b)*

	if 1:
		#fig = plt.figure( figsize=(6.5, 6.5), dpi=100)
		#ax = fig.add_subplot(111,aspect='equal')
		#line = ax.plot(z.real,z.imag,'b.', markersize = 1.5,  label = 'loop')
		t = np.linspace(-np.pi,np.pi ,200)
		#line = ax.plot(R*np.cos(t),R*np.sin(t),'b--', label = 'outer loop')
		

		sweep.circle_fit(Show_Plot=False)
		zc = np.complex(sweep.loop.a,sweep.loop.b)
		r = sweep.loop.r
		#line = ax.plot([zc.real],[zc.imag],'yx', markersize = 10, markeredgewidth = 4, label = 'Center')
		#line = line = ax.plot(zc.real + r*np.cos(t),zc.imag + r*np.sin(t),'r-', label = 'Circle Fit')
		#line = ax.plot([0,zc.real],[0,zc.imag],'y', markersize = 1 , label = 'Zc vector')


		sweep.phase_fit(Verbose = False)



# In [1805]: run -i test.ipy
# phi is -25.0, and theta is 20.0
# phi + theta =  355.0 deg, and alpha  = ang(zc) = 29.8778792072 deg, theta_f is 145.122120793, ztheta offset is -48.1867292992 

# In [1806]: run -i test.ipy
# phi is 25.0, and theta is -20.0
# phi + theta =  365.0 deg, and alpha  = ang(zc) = 330.122120793 deg, theta_f is 214.877879207, ztheta offset is 21.5690291152 

# In [1807]: run -i test.ipy
# phi is 25.0, and theta is 20.0
# phi + theta =  404.999999998 deg, and alpha  = ang(zc) = 10.1221207928 deg, theta_f is 214.877879205, ztheta offset is 21.5690291152 

# In [1808]: run -i test.ipy
# phi is -25.0, and theta is -20.0
# phi + theta =  315.0 deg, and alpha  = ang(zc) = 349.877879207 deg, theta_f is 145.122120793, ztheta offset is -48.1867292992 

# In [1839]: run -i test.ipy
# phi is -25.0, and theta is -90.0
# phi + theta =  605.0 deg, and alpha  = ang(zc) = 279.877879207 deg, theta_f is 145.122120793, ztheta offset is -48.1867292992 
# guess algorith:  phi + theta =  -115.0 deg

# In [1840]: run -i test.ipy
# phi is 25.0, and theta is -90.0
# phi + theta =  655.0 deg, and alpha  = ang(zc) = 260.122120793 deg, theta_f is 214.877879207, ztheta offset is 21.5690291152 
# guess algorith:  phi + theta =  -65.0 deg

# In [1841]: run -i test.ipy
# phi is 25.0, and theta is 90.0
# phi + theta =  474.999999998 deg, and alpha  = ang(zc) = 80.1221207928 deg, theta_f is 214.877879205, ztheta offset is 21.5690291152 
# guess algorith:  phi + theta =  114.999999998 deg

# In [1842]: run -i test.ipy
# phi is -25.0, and theta is 90.0
# phi + theta =  425.0 deg, and alpha  = ang(zc) = 99.8778792072 deg, theta_f is 145.122120793, ztheta offset is -48.1867292992 
# guess algorith:  phi + theta =  65.0 deg

# In [1843]: run -i test.ipy
# phi is -25.0, and theta is 180.0
# phi + theta =  515.0 deg, and alpha  = ang(zc) = 189.877879207 deg, theta_f is 145.122120793, ztheta offset is -48.1867292992 
# guess algorith:  phi + theta =  155.0 deg

# In [1844]: run -i test.ipy
# phi is 25.0, and theta is -180.0
# phi + theta =  565.0 deg, and alpha  = ang(zc) = 170.122120793 deg, theta_f is 214.877879207, ztheta offset is 21.5690291152 
# guess algorith:  phi + theta =  -155.0 deg

# In [1845]: run -i test.ipy
# phi is 25.0, and theta is 0.0
# phi + theta =  744.999999998 deg, and alpha  = ang(zc) = 350.122120793 deg, theta_f is 214.877879205, ztheta offset is 21.5690291152 
# guess algorith:  phi + theta =  24.999999998 deg

# In [1846]: run -i test.ipy
# phi is -25.0, and theta is 0.0
# phi + theta =  335.0 deg, and alpha  = ang(zc) = 9.87787920716 deg, theta_f is 145.122120793, ztheta offset is -48.1867292992 
# guess algorith:  phi + theta =  -25.0 deg

# In [1847]: run -i test.ipy
# phi is -10.0, and theta is 135.0
# phi + theta =  485.0 deg, and alpha  = ang(zc) = 139.228711 deg, theta_f is 165.771289, ztheta offset is -27.5375610916 
# guess algorith:  phi + theta =  125.0 deg


#xx In [1856]: run -i test.ipy
# phi is 10.0, and theta is 135.0
# phi + theta =  505.0 deg, and alpha  = ang(zc) = 130.771289 deg, theta_f is 194.228711, ztheta offset is 0.91986090755 
# guess algorith:  phi + theta =  -35.0 deg
